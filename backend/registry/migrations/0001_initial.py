# Generated by Django 5.2.8 on 2025-11-24 14:58

import django.contrib.gis.db.models.fields
import django.contrib.postgres.fields
import django.contrib.postgres.fields.ranges
import django.contrib.postgres.indexes
import django.contrib.postgres.search
import django.db.models.deletion
import django.db.models.expressions
import extras.models
import extras.validators
import registry.models.document
import registry.models.harvest
import registry.models.mapcontext
import registry.models.security
import simple_history.models
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
        ('contenttypes', '0002_remove_content_type_name'),
        ('django_celery_beat', '0019_alter_periodictasks_options'),
        ('mptt2', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='MaterializedHarvestingStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('service', models.UUIDField()),
                ('harvesting_job', models.IntegerField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('existed', models.IntegerField()),
            ],
            options={
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SearchableDatasetMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('title', models.CharField(default='', max_length=1000)),
                ('abstract', models.TextField(default='')),
                ('file_identifier', models.CharField(max_length=1000)),
                ('code', models.CharField(default='', max_length=4096)),
                ('code_space', models.CharField(default='', max_length=4096)),
                ('resource_identifier', models.CharField(default='', max_length=4096)),
                ('keywords_list', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=300), default=list, editable=False, size=None)),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('search_vector', django.contrib.postgres.search.SearchVectorField()),
                ('hierarchy_level', models.CharField(default='', max_length=100)),
            ],
            options={
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SearchableServiceMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('title', models.CharField(default='', max_length=1000)),
                ('abstract', models.TextField(default='')),
                ('file_identifier', models.CharField(max_length=1000)),
                ('code', models.CharField(default='', max_length=4096)),
                ('code_space', models.CharField(default='', max_length=4096)),
                ('resource_identifier', models.CharField(default='', max_length=4096)),
                ('keywords_list', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=300), default=list, editable=False, size=None)),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('search_vector', django.contrib.postgres.search.SearchVectorField()),
                ('hierarchy_level', models.CharField(default='', max_length=100)),
            ],
            options={
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AnalyzedResponseLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('entity_count', models.FloatField(help_text='Stores the response entity count. For WMS this will be the indiscreet number of megapixels that are returned by the service. For WFS this will be discrete number of feature types that are returned by the service.')),
                ('entity_total_count', models.FloatField(help_text='Stores the response entity total count. For WMS this will be the indiscreet number of megapixels that are returned by the service. For WFS this will be discrete number of feature types that are returned by the service.')),
            ],
        ),
        migrations.CreateModel(
            name='CatalogueService',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('version', models.PositiveSmallIntegerField(choices=[(1, '1.0.0'), (11, '1.1.0'), (111, '1.1.1'), (130, '1.3.0'), (200, '2.0.0'), (202, '2.0.2')], editable=False, help_text='the version of the service type as sem version', verbose_name='version')),
                ('service_url', models.URLField(editable=False, help_text='the base url of the service', max_length=4096, verbose_name='url')),
                ('max_step_size', models.IntegerField(default=50, help_text='the maximum step size this csw can handle by a single GetRecords request.', verbose_name='max step size')),
            ],
            options={
                'verbose_name': 'catalogue service',
                'verbose_name_plural': 'catalogue services',
            },
            bases=(extras.models.HistoricalRecordMixin, models.Model),
        ),
        migrations.CreateModel(
            name='ConformityCheckConfiguration',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=1000)),
                ('metadata_types', models.JSONField()),
                ('conformity_type', models.TextField(choices=[('internal', 'Internal'), ('etf', 'Etf')])),
            ],
        ),
        migrations.CreateModel(
            name='FeatureType',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('identifier', models.CharField(editable=False, help_text='this is a string which identifies the element on the remote service.', max_length=500, null=True, verbose_name='identifier')),
                ('bbox_lat_lon', django.contrib.gis.db.models.fields.PolygonField(blank=True, editable=False, help_text='bounding box shall be supplied regardless of what CRS the map server may support, but it may be approximate if the data are not natively in geographic coordinates. The purpose of bounding box is to facilitate geographic searches without requiring coordinate transformations by the search engine.', null=True, srid=4326, verbose_name='bounding box')),
                ('describe_feature_type_document', models.TextField(help_text='the fetched content of the download describe feature type document.', null=True, verbose_name='describe feature type')),
            ],
            options={
                'verbose_name': 'feature type',
                'verbose_name_plural': 'feature types',
            },
            bases=(extras.models.HistoricalRecordMixin, models.Model),
        ),
        migrations.CreateModel(
            name='Licence',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
                ('identifier', models.CharField(max_length=255, unique=True)),
                ('symbol_url', models.URLField(null=True)),
                ('description', models.TextField()),
                ('description_url', models.URLField(null=True)),
                ('is_open_data', models.BooleanField(default=False)),
            ],
        ),
        migrations.CreateModel(
            name='MapContext',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(help_text='a short descriptive title for this map context', max_length=1000, verbose_name='title')),
                ('language', models.CharField(choices=[('de', 'de'), ('en', 'en')], default='en', help_text='language of context document', max_length=4, verbose_name='language')),
                ('abstract', models.TextField(blank=True, help_text='brief summary of the topic of this map context', null=True, verbose_name='abstract')),
                ('pixel_width', models.PositiveIntegerField(blank=True, null=True, verbose_name='pixel width')),
                ('pixel_height', models.PositiveIntegerField(blank=True, null=True)),
                ('mm_per_pixel', models.FloatField(blank=True, null=True)),
                ('bbox', django.contrib.gis.db.models.fields.PolygonField(blank=True, null=True, srid=4326)),
            ],
            options={
                'ordering': ['title'],
            },
        ),
        migrations.CreateModel(
            name='MimeType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mime_type', models.CharField(db_index=True, help_text='The Internet Media Type', max_length=500, unique=True, verbose_name='mime type')),
            ],
        ),
        migrations.CreateModel(
            name='Rule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=1000)),
                ('field_name', models.TextField(choices=[('title', 'Title'), ('abstract', 'Abstract'), ('access_constraints', 'Access Constraints'), ('keywords', 'Keywords'), ('formats', 'Formats'), ('reference_system', 'Reference System')])),
                ('property', models.TextField(choices=[('len', 'Len'), ('count', 'Count')])),
                ('operator', models.TextField(choices=[('>', 'Gt'), ('>=', 'Gte'), ('<', 'Lt'), ('<=', 'Lte'), ('==', 'Eq'), ('!=', 'Neq')])),
                ('threshold', models.TextField(blank=True, default='')),
            ],
        ),
        migrations.CreateModel(
            name='WebFeatureServiceOperation',
            fields=[
                ('operation', models.PositiveSmallIntegerField(choices=[(30, 'GetFeature'), (31, 'Transaction')], primary_key=True, serialize=False)),
            ],
        ),
        migrations.CreateModel(
            name='WebMapServiceMonitoringRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the run was created in UTC', null=True, verbose_name='Created DateTime')),
                ('date_done', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the run was done in UTC', null=True, verbose_name='Done DateTime')),
            ],
        ),
        migrations.CreateModel(
            name='WebMapServiceOperation',
            fields=[
                ('operation', models.PositiveSmallIntegerField(choices=[(20, 'GetMap'), (21, 'GetFeatureInfo')], primary_key=True, serialize=False)),
            ],
        ),
        migrations.CreateModel(
            name='CatalogueServiceAuthentication',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('username', models.CharField(help_text='the username used for the authentication.', max_length=255, verbose_name='username')),
                ('password', models.CharField(help_text='the password used for the authentication.', max_length=500, verbose_name='password')),
                ('auth_type', models.CharField(choices=[('http_basic', 'Basic'), ('http_digest', 'Digest')], help_text='kind of authentication mechanism shall used.', max_length=100, verbose_name='authentication type')),
                ('key_file', models.FileField(editable=False, max_length=1024, upload_to=registry.models.security.key_file_path)),
                ('service', models.OneToOneField(blank=True, help_text='the optional authentication type and credentials to request the service.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='auth', related_query_name='auth', to='registry.catalogueservice', verbose_name='web feature service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='ConformityCheckConfigurationExternal',
            fields=[
                ('conformitycheckconfiguration_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='registry.conformitycheckconfiguration')),
                ('external_url', models.URLField(max_length=1000, null=True)),
                ('parameter_map', models.JSONField()),
                ('polling_interval_seconds', models.IntegerField(blank=True, default=5)),
                ('polling_interval_seconds_max', models.IntegerField(blank=True, default=300)),
            ],
            bases=('registry.conformitycheckconfiguration',),
        ),
        migrations.CreateModel(
            name='DatasetMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('inspire_interoperability', models.BooleanField(default=False, help_text='flag to signal if this ')),
                ('spatial_res_type', models.CharField(choices=[('groundDistance', 'Ground Distance'), ('scaleDenominator', 'Scale Distance')], default='', help_text='Ground resolution in meter or the equivalent scale.', max_length=20, verbose_name='resolution type')),
                ('spatial_res_value', models.FloatField(blank=True, help_text='The value depending on the selected resolution type.', null=True, verbose_name='resolution value')),
                ('code', models.CharField(blank=True, default='', help_text='identifier of the remote data', max_length=4096)),
                ('code_space', models.CharField(blank=True, default='', help_text='code space for the given identifier', max_length=4096)),
                ('resource_identifier', models.GeneratedField(db_persist=True, expression=django.db.models.expressions.CombinedExpression(models.F('code_space'), '||', models.F('code'), output_field=models.CharField()), output_field=models.CharField())),
                ('format', models.CharField(blank=True, choices=[('Database', 'Database'), ('Esri shape', 'Esri Shape'), ('CSV', 'Csv'), ('GML', 'Gml'), ('GeoTIFF', 'Geotiff')], default='', help_text='The format in which the described dataset is stored.', max_length=20, verbose_name='format')),
                ('charset', models.CharField(blank=True, choices=[('utf8', 'Utf8')], default='', help_text='The charset which is used by the stored data.', max_length=10, verbose_name='charset')),
                ('inspire_top_consistence', models.BooleanField(default=False, help_text='Flag to signal if the described data has a topologically consistence.')),
                ('preview_image', models.ImageField(blank=True, null=True, upload_to='')),
                ('lineage_statement', models.TextField(blank=True, default='')),
                ('update_frequency_code', models.CharField(blank=True, choices=[('annually', 'annually'), ('asNeeded', 'asNeeded'), ('biannually', 'biannually'), ('irregular', 'irregular'), ('notPlanned', 'notPlanned'), ('unknown', 'unknown')], default='', max_length=20)),
                ('harvested_through', models.ManyToManyField(blank=True, editable=False, help_text='all services from which this dataset was harvested.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', to='registry.catalogueservice', verbose_name='services')),
            ],
            options={
                'verbose_name': 'dataset metadata',
                'verbose_name_plural': 'dataset metadata',
            },
        ),
        migrations.CreateModel(
            name='DatasetMetadataConformityCheckRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('passed', models.BooleanField(blank=True, null=True)),
                ('report', models.TextField(blank=True, null=True)),
                ('report_type', models.TextField(choices=[('text/html', 'Html'), ('application/json', 'Json')])),
                ('config', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='registry.conformitycheckconfiguration')),
                ('dataset_metadata', models.ForeignKey(blank=True, help_text='the dataset metadata targeted by this check', null=True, on_delete=django.db.models.deletion.CASCADE, to='registry.datasetmetadatarecord', verbose_name='dataset metadata')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='FeatureTypeConformityCheckRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('passed', models.BooleanField(blank=True, null=True)),
                ('report', models.TextField(blank=True, null=True)),
                ('report_type', models.TextField(choices=[('text/html', 'Html'), ('application/json', 'Json')])),
                ('config', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='registry.conformitycheckconfiguration')),
                ('feature_type', models.ForeignKey(blank=True, help_text='the feature type targeted by this check', null=True, on_delete=django.db.models.deletion.CASCADE, to='registry.featuretype', verbose_name='feature type')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='FeatureTypeProperty',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('max_occurs', models.IntegerField(default=1, help_text='The maximum count this property is part of a feature type')),
                ('min_occurs', models.IntegerField(default=0, help_text='The minimum count this property is part of a feature type')),
                ('name', models.CharField(help_text='The identifing type name of the property', max_length=255)),
                ('data_type', models.CharField(blank=True, help_text='The concrete data type of this property', max_length=255, null=True)),
                ('required', models.BooleanField(default=False)),
                ('feature_type', models.ForeignKey(editable=False, help_text='related feature type of this property', on_delete=django.db.models.deletion.CASCADE, related_name='properties', related_query_name='property', to='registry.featuretype', verbose_name='feature type')),
            ],
            options={
                'verbose_name': 'feature type property',
                'verbose_name_plural': 'feature type properties',
                'ordering': ['-name'],
            },
        ),
        migrations.CreateModel(
            name='HarvestedMetadataRelation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('collecting_state', models.PositiveSmallIntegerField(choices=[(1, 'new'), (2, 'updated'), (3, 'existing'), (0, 'duplicated')])),
                ('download_duration', models.DurationField(blank=True, help_text='This is the duration it tooked proportionately to download this record. This means if the GetRecords response contains 50 records for example, the request duration was 50 * self.download_durationTo get the download duration over all for one harvesting job, aggregate this col.', null=True, verbose_name='download duration')),
                ('processing_duration', models.DurationField(blank=True, help_text='This is the duration it tooked to handle the processing of creating or updating this record.', null=True, verbose_name='processing duration')),
                ('history_date', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the relation was created', verbose_name='Created DateTime')),
                ('dataset_metadata_record', models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='harvested_dataset_metadata_relations', related_query_name='harvested_dataset_metadata_relation', to='registry.datasetmetadatarecord')),
            ],
        ),
        migrations.CreateModel(
            name='HarvestingJob',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_created', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the process was created in UTC', null=True, verbose_name='Created DateTime')),
                ('done_at', models.DateTimeField(blank=True, editable=False, help_text='Datetime field when the process was completed in UTC', null=True, verbose_name='Completed DateTime')),
                ('celery_task_ids', django.contrib.postgres.fields.ArrayField(base_field=models.UUIDField(), blank=True, default=list, editable=False, size=None)),
                ('max_step_size', models.PositiveSmallIntegerField(default=50, help_text='the maximum step size this csw can handle by a single GetRecords request.', verbose_name='max step size')),
                ('harvest_datasets', models.BooleanField(default=True)),
                ('harvest_services', models.BooleanField(default=True)),
                ('total_records', models.PositiveIntegerField(blank=True, editable=False, help_text='total count of records which will be harvested by this job', null=True, verbose_name='total records')),
                ('phase', models.PositiveSmallIntegerField(blank=True, choices=[(0, 'pending'), (1, 'get total records count'), (2, 'download records'), (3, 'records to db'), (4, 'completed'), (5, 'aborted'), (4711, 'abort')], default=0, help_text='Current phase of the process', verbose_name='phase')),
                ('log_level', models.PositiveSmallIntegerField(blank=True, choices=[(0, 'Fatal'), (1, 'Error'), (2, 'Warning'), (3, 'Info'), (4, 'Debug')], default=3)),
                ('harvested_dataset_metadata', models.ManyToManyField(blank=True, editable=False, related_name='harvesting_jobs', related_query_name='harvesting_job', through='registry.HarvestedMetadataRelation', to='registry.datasetmetadatarecord')),
                ('service', models.ForeignKey(help_text='the csw for that this job is running', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='harvesting_jobs', related_query_name='harvesting_job', to='registry.catalogueservice', verbose_name='service')),
            ],
            options={
                'verbose_name': 'Harvesting Job',
                'verbose_name_plural': 'Harvesting Jobs',
                'ordering': ['-date_created'],
                'get_latest_by': '-date_created',
                'abstract': False,
            },
        ),
        migrations.AddField(
            model_name='harvestedmetadatarelation',
            name='harvesting_job',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='harvested_metadata_relations', related_query_name='harvested_metadata_relation', to='registry.harvestingjob'),
        ),
        migrations.CreateModel(
            name='HarvestingLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timestamp', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the task result was created in UTC', verbose_name='Created DateTime')),
                ('level', models.PositiveSmallIntegerField(blank=True, choices=[(0, 'Fatal'), (1, 'Error'), (2, 'Warning'), (3, 'Info'), (4, 'Debug')], default=3)),
                ('kind', models.PositiveSmallIntegerField(blank=True, choices=[(None, '(Unknown)'), (0, 'Remote Error'), (1, 'received records count missmatch')], null=True)),
                ('description', models.CharField(blank=True, default='', max_length=512, verbose_name='Description')),
                ('extented_description', models.FileField(help_text='this can be the response content for example', null=True, upload_to=registry.models.harvest.extented_description_file_path, verbose_name='Extented Description')),
                ('harvesting_job', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='logs', related_query_name='log', to='registry.harvestingjob')),
            ],
        ),
        migrations.CreateModel(
            name='HistoricalHarvestingJob',
            fields=[
                ('id', models.BigIntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('date_created', models.DateTimeField(blank=True, editable=False, help_text='Datetime field when the process was created in UTC', null=True, verbose_name='Created DateTime')),
                ('done_at', models.DateTimeField(blank=True, editable=False, help_text='Datetime field when the process was completed in UTC', null=True, verbose_name='Completed DateTime')),
                ('celery_task_ids', django.contrib.postgres.fields.ArrayField(base_field=models.UUIDField(), blank=True, default=list, editable=False, size=None)),
                ('max_step_size', models.PositiveSmallIntegerField(default=50, help_text='the maximum step size this csw can handle by a single GetRecords request.', verbose_name='max step size')),
                ('harvest_datasets', models.BooleanField(default=True)),
                ('harvest_services', models.BooleanField(default=True)),
                ('total_records', models.PositiveIntegerField(blank=True, editable=False, help_text='total count of records which will be harvested by this job', null=True, verbose_name='total records')),
                ('phase', models.PositiveSmallIntegerField(blank=True, choices=[(0, 'pending'), (1, 'get total records count'), (2, 'download records'), (3, 'records to db'), (4, 'completed'), (5, 'aborted'), (4711, 'abort')], default=0, help_text='Current phase of the process', verbose_name='phase')),
                ('log_level', models.PositiveSmallIntegerField(blank=True, choices=[(0, 'Fatal'), (1, 'Error'), (2, 'Warning'), (3, 'Info'), (4, 'Debug')], default=3)),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.harvestingjob')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('service', models.ForeignKey(blank=True, db_constraint=False, help_text='the csw for that this job is running', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='harvesting_job', to='registry.catalogueservice', verbose_name='service')),
            ],
            options={
                'verbose_name': 'historical Harvesting Job',
                'verbose_name_plural': 'historical Harvesting Jobs',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='Keyword',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('keyword', models.CharField(max_length=300)),
            ],
            options={
                'ordering': ['keyword'],
                'indexes': [models.Index(fields=['keyword'], name='registry_ke_keyword_86359a_idx')],
                'constraints': [models.UniqueConstraint(fields=('keyword',), name='registry_keyword_unique_keywords'), models.CheckConstraint(condition=models.Q(models.Q(('keyword', ''), _negated=True), models.Q(('keyword__isnull', True), _negated=True), _connector='OR'), name='registry_keyword_non_empty_keywords')],
            },
        ),
        migrations.AddField(
            model_name='featuretype',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.AddField(
            model_name='catalogueservice',
            name='keywords',
            field=models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords'),
        ),
        migrations.CreateModel(
            name='Layer',
            fields=[
                ('mptt_lft', models.PositiveIntegerField(editable=False, help_text='The left value of the node', verbose_name='left')),
                ('mptt_rgt', models.PositiveIntegerField(editable=False, help_text='The right value of the node', verbose_name='right')),
                ('mptt_depth', models.PositiveIntegerField(editable=False, help_text='The hierarchy level of this node inside the tree', verbose_name='depth')),
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('preview_image', models.ImageField(blank=True, null=True, upload_to='')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('identifier', models.CharField(editable=False, help_text='this is a string which identifies the element on the remote service.', max_length=500, null=True, verbose_name='identifier')),
                ('bbox_lat_lon', django.contrib.gis.db.models.fields.PolygonField(blank=True, editable=False, help_text='bounding box shall be supplied regardless of what CRS the map server may support, but it may be approximate if the data are not natively in geographic coordinates. The purpose of bounding box is to facilitate geographic searches without requiring coordinate transformations by the search engine.', null=True, srid=4326, verbose_name='bounding box')),
                ('is_queryable', models.BooleanField(default=False, editable=False, help_text='flag to signal if this layer provides factual information or not. Parsed from capabilities.', verbose_name='is queryable')),
                ('is_opaque', models.BooleanField(default=False, editable=False, help_text='flag to signal if this layer support transparency content or not. Parsed from capabilities.', verbose_name='is opaque')),
                ('is_cascaded', models.BooleanField(default=False, editable=False, help_text='WMS cascading allows to expose layers coming from other WMS servers as if they were local layers', verbose_name='is cascaded')),
                ('scale_min', models.FloatField(blank=True, editable=False, help_text='minimum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale minimum value')),
                ('scale_max', models.FloatField(blank=True, editable=False, help_text='maximum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale maximum value')),
                ('keywords', models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords')),
                ('mptt_parent', models.ForeignKey(editable=False, help_text='The parent of this node', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='chilren', related_query_name='child', to='registry.layer', verbose_name='parent')),
                ('mptt_tree', models.ForeignKey(editable=False, help_text='The unique tree, where this node is part of', on_delete=django.db.models.deletion.CASCADE, related_name='%(app_label)s_%(class)s_nodes', related_query_name='%(app_label)s_%(class)s_node', to='mptt2.tree', verbose_name='tree')),
            ],
            options={
                'verbose_name': 'layer',
                'verbose_name_plural': 'layers',
            },
            bases=(extras.models.HistoricalRecordMixin, models.Model),
        ),
        migrations.CreateModel(
            name='LayerConformityCheckRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('passed', models.BooleanField(blank=True, null=True)),
                ('report', models.TextField(blank=True, null=True)),
                ('report_type', models.TextField(choices=[('text/html', 'Html'), ('application/json', 'Json')])),
                ('config', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='registry.conformitycheckconfiguration')),
                ('layer', models.ForeignKey(blank=True, help_text='the layer targeted by this check', null=True, on_delete=django.db.models.deletion.CASCADE, to='registry.layer', verbose_name='layer')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='licence',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence'),
        ),
        migrations.AddField(
            model_name='catalogueservice',
            name='licence',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence'),
        ),
        migrations.CreateModel(
            name='HistoricalMapContext',
            fields=[
                ('id', models.BigIntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('title', models.CharField(help_text='a short descriptive title for this map context', max_length=1000, verbose_name='title')),
                ('language', models.CharField(choices=[('de', 'de'), ('en', 'en')], default='en', help_text='language of context document', max_length=4, verbose_name='language')),
                ('abstract', models.TextField(blank=True, help_text='brief summary of the topic of this map context', null=True, verbose_name='abstract')),
                ('pixel_width', models.PositiveIntegerField(blank=True, null=True, verbose_name='pixel width')),
                ('pixel_height', models.PositiveIntegerField(blank=True, null=True)),
                ('mm_per_pixel', models.FloatField(blank=True, null=True)),
                ('bbox', django.contrib.gis.db.models.fields.PolygonField(blank=True, null=True, srid=4326)),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.mapcontext')),
            ],
            options={
                'verbose_name': 'historical map context',
                'verbose_name_plural': 'historical map contexts',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='MaterializedCatalogueServiceStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_45c1c1_idx'), models.Index(fields=['history_day'], name='registry_ma_history_a3ed53_idx'), models.Index(fields=['new'], name='registry_ma_new_bcea64_idx'), models.Index(fields=['updated'], name='registry_ma_updated_86f5c0_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_0359b5_idx')],
            },
        ),
        migrations.CreateModel(
            name='MaterializedDatasetMetadataRecordStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_3b76b7_idx'), models.Index(fields=['history_day'], name='registry_ma_history_0680a6_idx'), models.Index(fields=['new'], name='registry_ma_new_32b8e7_idx'), models.Index(fields=['updated'], name='registry_ma_updated_4ddcdf_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_84d485_idx')],
            },
        ),
        migrations.CreateModel(
            name='MaterializedFeatureTypeStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_7ed1ed_idx'), models.Index(fields=['history_day'], name='registry_ma_history_c8b26d_idx'), models.Index(fields=['new'], name='registry_ma_new_b81bc8_idx'), models.Index(fields=['updated'], name='registry_ma_updated_561b29_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_cd6cc6_idx')],
            },
        ),
        migrations.CreateModel(
            name='MaterializedLayerStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_c229d3_idx'), models.Index(fields=['history_day'], name='registry_ma_history_82a624_idx'), models.Index(fields=['new'], name='registry_ma_new_466854_idx'), models.Index(fields=['updated'], name='registry_ma_updated_99e320_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_2b3df9_idx')],
            },
        ),
        migrations.CreateModel(
            name='MaterializedServiceMetadataRecordStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_6710ed_idx'), models.Index(fields=['history_day'], name='registry_ma_history_5f3365_idx'), models.Index(fields=['new'], name='registry_ma_new_3c5bd2_idx'), models.Index(fields=['updated'], name='registry_ma_updated_e0086a_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_322e82_idx')],
            },
        ),
        migrations.CreateModel(
            name='MaterializedWebFeatureServiceStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_45213f_idx'), models.Index(fields=['history_day'], name='registry_ma_history_54b8de_idx'), models.Index(fields=['new'], name='registry_ma_new_e849e4_idx'), models.Index(fields=['updated'], name='registry_ma_updated_fc2360_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_b7373a_idx')],
            },
        ),
        migrations.CreateModel(
            name='MaterializedWebMapServiceStatsPerDay',
            fields=[
                ('id', models.DateField(primary_key=True, serialize=False)),
                ('history_day', models.DateField()),
                ('new', models.IntegerField()),
                ('updated', models.IntegerField()),
                ('deleted', models.IntegerField()),
            ],
            options={
                'indexes': [models.Index(fields=['id'], name='registry_ma_id_564aad_idx'), models.Index(fields=['history_day'], name='registry_ma_history_6f976d_idx'), models.Index(fields=['new'], name='registry_ma_new_b362ac_idx'), models.Index(fields=['updated'], name='registry_ma_updated_462240_idx'), models.Index(fields=['deleted'], name='registry_ma_deleted_c5367d_idx')],
            },
        ),
        migrations.CreateModel(
            name='MetadataContact',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(default='', help_text='The name of the organization', max_length=256, verbose_name='Name')),
                ('person_name', models.CharField(default='', max_length=200, verbose_name='Contact person')),
                ('email', models.EmailField(default='', max_length=100, verbose_name='E-Mail')),
                ('phone', models.CharField(default='', max_length=100, verbose_name='Phone')),
                ('facsimile', models.CharField(default='', max_length=100, verbose_name='Facsimile')),
                ('city', models.CharField(default='', max_length=100, verbose_name='City')),
                ('postal_code', models.CharField(default='', max_length=100, verbose_name='Postal code')),
                ('address_type', models.CharField(default='', max_length=100, verbose_name='Address type')),
                ('address', models.CharField(default='', max_length=100, verbose_name='Address')),
                ('state_or_province', models.CharField(default='', max_length=100, verbose_name='State or province')),
                ('country', models.CharField(default='', max_length=100, verbose_name='Country')),
            ],
            options={
                'ordering': ['name'],
                'constraints': [models.UniqueConstraint(fields=('name', 'person_name', 'email', 'phone', 'facsimile', 'city', 'postal_code', 'address_type', 'address', 'state_or_province', 'country'), name='registry_metadatacontact_unique_together_metadata_contact')],
            },
        ),
        migrations.CreateModel(
            name='HistoricalDatasetMetadataRecord',
            fields=[
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('inspire_interoperability', models.BooleanField(default=False, help_text='flag to signal if this ')),
                ('spatial_res_type', models.CharField(choices=[('groundDistance', 'Ground Distance'), ('scaleDenominator', 'Scale Distance')], default='', help_text='Ground resolution in meter or the equivalent scale.', max_length=20, verbose_name='resolution type')),
                ('spatial_res_value', models.FloatField(blank=True, help_text='The value depending on the selected resolution type.', null=True, verbose_name='resolution value')),
                ('code', models.CharField(blank=True, default='', help_text='identifier of the remote data', max_length=4096)),
                ('code_space', models.CharField(blank=True, default='', help_text='code space for the given identifier', max_length=4096)),
                ('resource_identifier', models.GeneratedField(db_persist=True, expression=django.db.models.expressions.CombinedExpression(models.F('code_space'), '||', models.F('code'), output_field=models.CharField()), output_field=models.CharField())),
                ('format', models.CharField(blank=True, choices=[('Database', 'Database'), ('Esri shape', 'Esri Shape'), ('CSV', 'Csv'), ('GML', 'Gml'), ('GeoTIFF', 'Geotiff')], default='', help_text='The format in which the described dataset is stored.', max_length=20, verbose_name='format')),
                ('charset', models.CharField(blank=True, choices=[('utf8', 'Utf8')], default='', help_text='The charset which is used by the stored data.', max_length=10, verbose_name='charset')),
                ('inspire_top_consistence', models.BooleanField(default=False, help_text='Flag to signal if the described data has a topologically consistence.')),
                ('preview_image', models.TextField(blank=True, max_length=100, null=True)),
                ('lineage_statement', models.TextField(blank=True, default='')),
                ('update_frequency_code', models.CharField(blank=True, choices=[('annually', 'annually'), ('asNeeded', 'asNeeded'), ('biannually', 'biannually'), ('irregular', 'irregular'), ('notPlanned', 'notPlanned'), ('unknown', 'unknown')], default='', max_length=20)),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.datasetmetadatarecord')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('licence', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.licence')),
                ('dataset_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='this is the contact which provides this dataset.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='%(class)s_dataset_contact', to='registry.metadatacontact', verbose_name='contact')),
                ('metadata_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='this is the contact which is responsible for the metadata information of the dataset.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='%(class)s_metadata_contact', to='registry.metadatacontact', verbose_name='contact')),
            ],
            options={
                'verbose_name': 'historical dataset metadata',
                'verbose_name_plural': 'historical dataset metadata',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalCatalogueService',
            fields=[
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('version', models.PositiveSmallIntegerField(choices=[(1, '1.0.0'), (11, '1.1.0'), (111, '1.1.1'), (130, '1.3.0'), (200, '2.0.0'), (202, '2.0.2')], editable=False, help_text='the version of the service type as sem version', verbose_name='version')),
                ('service_url', models.URLField(editable=False, help_text='the base url of the service', max_length=4096, verbose_name='url')),
                ('max_step_size', models.IntegerField(default=50, help_text='the maximum step size this csw can handle by a single GetRecords request.', verbose_name='max step size')),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.catalogueservice')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('licence', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.licence')),
                ('metadata_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='This is the contact for the metadata information.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.metadatacontact', verbose_name='metadata contact')),
                ('service_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='This is the contact for the service provider.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.metadatacontact', verbose_name='service contact')),
            ],
            options={
                'verbose_name': 'historical catalogue service',
                'verbose_name_plural': 'historical catalogue services',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='dataset_contact',
            field=models.ForeignKey(help_text='this is the contact which provides this dataset.', on_delete=django.db.models.deletion.RESTRICT, related_name='%(class)s_dataset_contact', related_query_name='%(class)s_dataset_contact', to='registry.metadatacontact', verbose_name='contact'),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='metadata_contact',
            field=models.ForeignKey(help_text='this is the contact which is responsible for the metadata information of the dataset.', on_delete=django.db.models.deletion.RESTRICT, related_name='%(class)s_metadata_contact', related_query_name='%(class)s_metadata_contact', to='registry.metadatacontact', verbose_name='contact'),
        ),
        migrations.AddField(
            model_name='catalogueservice',
            name='metadata_contact',
            field=models.ForeignKey(help_text='This is the contact for the metadata information.', on_delete=django.db.models.deletion.RESTRICT, related_name='metadata_contact_%(class)s_metadata', to='registry.metadatacontact', verbose_name='metadata contact'),
        ),
        migrations.AddField(
            model_name='catalogueservice',
            name='service_contact',
            field=models.ForeignKey(help_text='This is the contact for the service provider.', on_delete=django.db.models.deletion.RESTRICT, related_name='service_contact_%(class)s_metadata', to='registry.metadatacontact', verbose_name='service contact'),
        ),
        migrations.CreateModel(
            name='MetadataRelation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_internal', models.BooleanField(default=False, help_text='true means that this relation is created by a user and the dataset is maybe not linked in a capabilities document for example.', verbose_name='internal relation?')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], help_text='determines where this relation was found or it is added by a user.', max_length=20, verbose_name='origin')),
                ('csw', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.catalogueservice')),
                ('dataset_metadata', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='resource_relations', related_query_name='resource_relation', to='registry.datasetmetadatarecord')),
                ('feature_type', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.featuretype')),
                ('layer', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.layer')),
            ],
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='self_pointing_feature_types',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all feature types which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.featuretype', verbose_name='feature types'),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='self_pointing_layers',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all layers which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.layer', verbose_name='layers'),
        ),
        migrations.AddField(
            model_name='featuretype',
            name='output_formats',
            field=models.ManyToManyField(blank=True, editable=False, help_text='This is a list of MIME types indicating the output formats that may be generated for a feature type.  If this optional element is not specified, then all the result formats listed for the GetFeature operation are assumed to be supported. ', related_name='feature_types', related_query_name='feature_type', to='registry.mimetype', verbose_name='output formats'),
        ),
        migrations.CreateModel(
            name='CatalogueServiceOperationUrl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method', models.PositiveSmallIntegerField(choices=[(1, 'Get'), (2, 'Post')], help_text='the http method you can perform for this url', verbose_name='http method')),
                ('operation', models.PositiveSmallIntegerField(choices=[(1, 'GetCapabilities'), (20, 'GetMap'), (21, 'GetFeatureInfo'), (22, 'DescribeLayer'), (23, 'GetLegendGraphic'), (24, 'GetStyles'), (25, 'PutStyles'), (30, 'GetFeature'), (31, 'Transaction'), (32, 'LockFeature'), (33, 'DescribeFeatureType'), (34, 'GetFeatureWithLock'), (35, 'GetGmlObject'), (36, 'ListStoredQueries'), (37, 'GetPropertyValue'), (38, 'DescribeStoredQueries'), (39, 'CreateStoredQuery'), (40, 'DropStoredQuery'), (50, 'GetRecords'), (51, 'DescribeRecord'), (52, 'GetRecordById'), (53, 'GetDomain'), (54, 'GetRepositoryItem')], help_text='the operation you can perform with this url.', verbose_name='operation')),
                ('url', models.URLField(help_text='the url for this operation', max_length=4096, verbose_name='url')),
                ('service', models.ForeignKey(editable=False, help_text='the catalogue service for that this url can be used for.', on_delete=django.db.models.deletion.CASCADE, related_name='operation_urls', related_query_name='operation_url', to='registry.catalogueservice', verbose_name='related catalogue service')),
                ('mime_types', models.ManyToManyField(blank=True, help_text='all available mime types of the remote url', related_name='%(class)s_operation_urls', related_query_name='%(class)s_operation_url', to='registry.mimetype', verbose_name='internet mime type')),
            ],
        ),
        migrations.CreateModel(
            name='PeriodicHarvestingJob',
            fields=[
                ('periodictask_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='django_celery_beat.periodictask')),
                ('service', models.ForeignKey(help_text='this is the service which shall be harvested', on_delete=django.db.models.deletion.CASCADE, related_name='periodic_harvesting_jobs', related_query_name='periodic_harvesting_job', to='registry.catalogueservice', verbose_name='catalogue service')),
            ],
            options={
                'verbose_name': 'Periodic Harvesting Job',
                'verbose_name_plural': 'Periodic Harvesting Jobs',
            },
            bases=('django_celery_beat.periodictask',),
        ),
        migrations.CreateModel(
            name='ReferenceSystem',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('code', models.CharField(default='', max_length=100)),
                ('prefix', models.CharField(choices=[('EPSG', 'Epsg')], default='', max_length=255)),
            ],
            options={
                'ordering': ['-code'],
                'constraints': [models.UniqueConstraint(fields=('code', 'prefix'), name='registry_referencesystem_unique_code_prefix')],
            },
        ),
        migrations.AddField(
            model_name='layer',
            name='reference_systems',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all reference systems which this element supports', related_name='%(class)s', related_query_name='%(class)s', to='registry.referencesystem', verbose_name='reference systems'),
        ),
        migrations.AddField(
            model_name='featuretype',
            name='reference_systems',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all reference systems which this element supports', related_name='%(class)s', related_query_name='%(class)s', to='registry.referencesystem', verbose_name='reference systems'),
        ),
        migrations.AddField(
            model_name='datasetmetadatarecord',
            name='reference_systems',
            field=models.ManyToManyField(blank=True, related_name='%(class)s', related_query_name='%(class)s', to='registry.referencesystem', verbose_name='reference systems'),
        ),
        migrations.CreateModel(
            name='RuleSet',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=1000)),
                ('rules', models.ManyToManyField(related_name='rule_set', to='registry.rule')),
            ],
        ),
        migrations.CreateModel(
            name='ServiceMetadataRecord',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('inspire_interoperability', models.BooleanField(default=False, help_text='flag to signal if this ')),
                ('spatial_res_type', models.CharField(choices=[('groundDistance', 'Ground Distance'), ('scaleDenominator', 'Scale Distance')], default='', help_text='Ground resolution in meter or the equivalent scale.', max_length=20, verbose_name='resolution type')),
                ('spatial_res_value', models.FloatField(blank=True, help_text='The value depending on the selected resolution type.', null=True, verbose_name='resolution value')),
                ('code', models.CharField(blank=True, default='', help_text='identifier of the remote data', max_length=4096)),
                ('code_space', models.CharField(blank=True, default='', help_text='code space for the given identifier', max_length=4096)),
                ('resource_identifier', models.GeneratedField(db_persist=True, expression=django.db.models.expressions.CombinedExpression(models.F('code_space'), '||', models.F('code'), output_field=models.CharField()), output_field=models.CharField())),
                ('harvested_through', models.ManyToManyField(blank=True, editable=False, help_text='all services from which this dataset was harvested.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', to='registry.catalogueservice', verbose_name='services')),
                ('keywords', models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords')),
                ('licence', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence')),
                ('metadata_contact', models.ForeignKey(help_text='this is the contact which is responsible for the metadata information of the dataset.', on_delete=django.db.models.deletion.RESTRICT, related_name='%(class)s_metadata_contact', related_query_name='%(class)s_metadata_contact', to='registry.metadatacontact', verbose_name='contact')),
                ('reference_systems', models.ManyToManyField(blank=True, related_name='%(class)s', related_query_name='%(class)s', to='registry.referencesystem', verbose_name='reference systems')),
                ('self_pointing_csw', models.ManyToManyField(blank=True, editable=False, help_text='all csw which are linking to this service metadata in there capabilities.', related_name='%(app_label)s_%(class)s_service_metadata', related_query_name='%(app_label)s_%(class)s_service_metadata', through='registry.MetadataRelation', to='registry.catalogueservice', verbose_name='catalogue services')),
                ('self_pointing_feature_types', models.ManyToManyField(blank=True, editable=False, help_text='all feature types which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.featuretype', verbose_name='feature types')),
                ('self_pointing_layers', models.ManyToManyField(blank=True, editable=False, help_text='all layers which are linking to this dataset metadata in there capabilities.', related_name='%(app_label)s_%(class)s_metadata_records', related_query_name='%(app_label)s_%(class)s_metadata_record', through='registry.MetadataRelation', to='registry.layer', verbose_name='layers')),
            ],
        ),
        migrations.AddField(
            model_name='metadatarelation',
            name='service_metadata',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='resource_relations', related_query_name='resource_relation', to='registry.servicemetadatarecord'),
        ),
        migrations.CreateModel(
            name='HistoricalServiceMetadataRecord',
            fields=[
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('bounding_geometry', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326)),
                ('inspire_interoperability', models.BooleanField(default=False, help_text='flag to signal if this ')),
                ('spatial_res_type', models.CharField(choices=[('groundDistance', 'Ground Distance'), ('scaleDenominator', 'Scale Distance')], default='', help_text='Ground resolution in meter or the equivalent scale.', max_length=20, verbose_name='resolution type')),
                ('spatial_res_value', models.FloatField(blank=True, help_text='The value depending on the selected resolution type.', null=True, verbose_name='resolution value')),
                ('code', models.CharField(blank=True, default='', help_text='identifier of the remote data', max_length=4096)),
                ('code_space', models.CharField(blank=True, default='', help_text='code space for the given identifier', max_length=4096)),
                ('resource_identifier', models.GeneratedField(db_persist=True, expression=django.db.models.expressions.CombinedExpression(models.F('code_space'), '||', models.F('code'), output_field=models.CharField()), output_field=models.CharField())),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('licence', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.licence')),
                ('metadata_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='this is the contact which is responsible for the metadata information of the dataset.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='%(class)s_metadata_contact', to='registry.metadatacontact', verbose_name='contact')),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.servicemetadatarecord')),
            ],
            options={
                'verbose_name': 'historical service metadata record',
                'verbose_name_plural': 'historical service metadata records',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.AddField(
            model_name='harvestingjob',
            name='harvested_service_metadata',
            field=models.ManyToManyField(blank=True, editable=False, related_name='harvesting_jobs', related_query_name='harvesting_job', through='registry.HarvestedMetadataRelation', to='registry.servicemetadatarecord'),
        ),
        migrations.AddField(
            model_name='harvestedmetadatarelation',
            name='service_metadata_record',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='harvested_service_metadata_relations', related_query_name='harvested_service_metadata_relation', to='registry.servicemetadatarecord'),
        ),
        migrations.CreateModel(
            name='Style',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(editable=False, help_text="The style's Name is used in the Map request STYLES parameter to lookup the style on server side.", max_length=255, verbose_name='name')),
                ('title', models.CharField(editable=False, help_text='The Title is a human-readable string as an alternative for the name attribute.', max_length=255, verbose_name='title')),
                ('layer', models.ForeignKey(editable=False, help_text='the layer for that this style is for.', on_delete=django.db.models.deletion.CASCADE, related_name='styles', related_query_name='style', to='registry.layer', verbose_name='related layer')),
            ],
        ),
        migrations.CreateModel(
            name='MapContextLayer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('mptt_lft', models.PositiveIntegerField(editable=False, help_text='The left value of the node', verbose_name='left')),
                ('mptt_rgt', models.PositiveIntegerField(editable=False, help_text='The right value of the node', verbose_name='right')),
                ('mptt_depth', models.PositiveIntegerField(editable=False, help_text='The hierarchy level of this node inside the tree', verbose_name='depth')),
                ('layer_scale_min', models.FloatField(blank=True, help_text='minimum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale minimum value')),
                ('layer_scale_max', models.FloatField(blank=True, help_text='maximum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale maximum value')),
                ('preview_image', models.ImageField(blank=True, help_text='A preview image for the Map Context Layer', null=True, upload_to=registry.models.mapcontext.preview_image_file_path, verbose_name='preview image')),
                ('rendering_active', models.BooleanField(blank=True, default=True, help_text='should this offering be visible?', verbose_name='rendering active')),
                ('selection_active', models.BooleanField(blank=True, default=True, help_text='should this offering be visible?', verbose_name='rendering active')),
                ('title', models.CharField(help_text='an identifying name for this map context layer', max_length=1000, verbose_name='title')),
                ('description', models.CharField(blank=True, help_text='a short description for this map context layer', max_length=1000, null=True, verbose_name='description')),
                ('dataset_metadata', models.ForeignKey(blank=True, help_text='You can use this field to pre filter possible Layer selection.', null=True, on_delete=django.db.models.deletion.PROTECT, to='registry.datasetmetadatarecord', verbose_name='Dataset Metadata')),
                ('map_context', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='map_context_layers', related_query_name='map_context_layer', to='registry.mapcontext')),
                ('mptt_parent', models.ForeignKey(editable=False, help_text='The parent of this node', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='chilren', related_query_name='child', to='registry.mapcontextlayer', verbose_name='parent')),
                ('mptt_tree', models.ForeignKey(editable=False, help_text='The unique tree, where this node is part of', on_delete=django.db.models.deletion.CASCADE, related_name='%(app_label)s_%(class)s_nodes', related_query_name='%(app_label)s_%(class)s_node', to='mptt2.tree', verbose_name='tree')),
                ('rendering_layer', models.ForeignKey(blank=True, help_text='Select a layer for rendering.', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='mapcontextlayers_rendering', to='registry.layer', verbose_name='Rendering layer')),
                ('selection_layer', models.ForeignKey(blank=True, help_text='Select a layer for feature selection.', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='mapcontextlayers_selection', to='registry.layer', verbose_name='Selection layer')),
                ('layer_style', models.ForeignKey(blank=True, help_text='Select a style for rendering.', null=True, on_delete=django.db.models.deletion.PROTECT, to='registry.style', verbose_name='Style')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='LegendUrl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('legend_url', models.URLField(editable=False, help_text='contains the location of an image of a map legend appropriate to the enclosing Style.', max_length=4096)),
                ('height', models.IntegerField(editable=False, help_text='the size of the image in pixels')),
                ('width', models.IntegerField(editable=False, help_text='the size of the image in pixels')),
                ('mime_type', models.ForeignKey(editable=False, help_text='the mime type of the remote legend url', on_delete=django.db.models.deletion.RESTRICT, related_name='legend_urls', related_query_name='legend_url', to='registry.mimetype', verbose_name='internet mime type')),
                ('style', models.OneToOneField(editable=False, help_text='the style entity which is linked to this legend url', on_delete=django.db.models.deletion.CASCADE, related_name='legend_url', related_query_name='legend_url', to='registry.style', verbose_name='related style')),
            ],
        ),
        migrations.CreateModel(
            name='HistoricalMapContextLayer',
            fields=[
                ('id', models.BigIntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('mptt_lft', models.PositiveIntegerField(editable=False, help_text='The left value of the node', verbose_name='left')),
                ('mptt_rgt', models.PositiveIntegerField(editable=False, help_text='The right value of the node', verbose_name='right')),
                ('mptt_depth', models.PositiveIntegerField(editable=False, help_text='The hierarchy level of this node inside the tree', verbose_name='depth')),
                ('layer_scale_min', models.FloatField(blank=True, help_text='minimum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale minimum value')),
                ('layer_scale_max', models.FloatField(blank=True, help_text='maximum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale maximum value')),
                ('preview_image', models.TextField(blank=True, help_text='A preview image for the Map Context Layer', max_length=100, null=True, verbose_name='preview image')),
                ('rendering_active', models.BooleanField(blank=True, default=True, help_text='should this offering be visible?', verbose_name='rendering active')),
                ('selection_active', models.BooleanField(blank=True, default=True, help_text='should this offering be visible?', verbose_name='rendering active')),
                ('title', models.CharField(help_text='an identifying name for this map context layer', max_length=1000, verbose_name='title')),
                ('description', models.CharField(blank=True, help_text='a short description for this map context layer', max_length=1000, null=True, verbose_name='description')),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('dataset_metadata', models.ForeignKey(blank=True, db_constraint=False, help_text='You can use this field to pre filter possible Layer selection.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.datasetmetadatarecord', verbose_name='Dataset Metadata')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('mptt_tree', models.ForeignKey(blank=True, db_constraint=False, editable=False, help_text='The unique tree, where this node is part of', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='%(app_label)s_%(class)s_node', to='mptt2.tree', verbose_name='tree')),
                ('rendering_layer', models.ForeignKey(blank=True, db_constraint=False, help_text='Select a layer for rendering.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.layer', verbose_name='Rendering layer')),
                ('selection_layer', models.ForeignKey(blank=True, db_constraint=False, help_text='Select a layer for feature selection.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.layer', verbose_name='Selection layer')),
                ('map_context', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='map_context_layer', to='registry.mapcontext')),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.mapcontextlayer')),
                ('mptt_parent', models.ForeignKey(blank=True, db_constraint=False, editable=False, help_text='The parent of this node', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='child', to='registry.mapcontextlayer', verbose_name='parent')),
                ('layer_style', models.ForeignKey(blank=True, db_constraint=False, help_text='Select a style for rendering.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.style', verbose_name='Style')),
            ],
            options={
                'verbose_name': 'historical map context layer',
                'verbose_name_plural': 'historical map context layers',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='TemporaryMdMetadataFile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('md_metadata_file', models.FileField(help_text='the content of the http response, or of the imported file', upload_to=registry.models.harvest.response_file_path, verbose_name='response')),
                ('re_schedule', models.BooleanField(default=False, help_text='to re run to db task')),
                ('has_import_error', models.BooleanField(default=False, editable=False, help_text="signals if this object can't be imported")),
                ('import_error', models.TextField(blank=True, default='', help_text='raised error while importing', verbose_name='import error')),
                ('request_id', models.DateTimeField(null=True)),
                ('requested_url', models.URLField(max_length=4096, null=True)),
                ('download_duration', models.DurationField(blank=True, help_text='This is the duration it tooked proportionately to download this record. This means if the GetRecords response contains 50 records for example, the request duration was 50 * self.download_duration', null=True, verbose_name='download duration')),
                ('job', models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='temporary_md_metadata_files', related_query_name='temporary_md_metadata_file', to='registry.harvestingjob', verbose_name='harvesting job')),
            ],
        ),
        migrations.CreateModel(
            name='WebFeatureService',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('version', models.PositiveSmallIntegerField(choices=[(1, '1.0.0'), (11, '1.1.0'), (111, '1.1.1'), (130, '1.3.0'), (200, '2.0.0'), (202, '2.0.2')], editable=False, help_text='the version of the service type as sem version', verbose_name='version')),
                ('service_url', models.URLField(editable=False, help_text='the base url of the service', max_length=4096, verbose_name='url')),
                ('keywords', models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords')),
                ('licence', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence')),
                ('metadata_contact', models.ForeignKey(help_text='This is the contact for the metadata information.', on_delete=django.db.models.deletion.RESTRICT, related_name='metadata_contact_%(class)s_metadata', to='registry.metadatacontact', verbose_name='metadata contact')),
                ('service_contact', models.ForeignKey(help_text='This is the contact for the service provider.', on_delete=django.db.models.deletion.RESTRICT, related_name='service_contact_%(class)s_metadata', to='registry.metadatacontact', verbose_name='service contact')),
            ],
            options={
                'verbose_name': 'web feature service',
                'verbose_name_plural': 'web feature services',
            },
            bases=(extras.models.HistoricalRecordMixin, models.Model),
        ),
        migrations.AddField(
            model_name='servicemetadatarecord',
            name='self_pointing_wfs',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all wfs which are linking to this service metadata in there capabilities.', related_name='%(app_label)s_%(class)s_service_metadata', related_query_name='%(app_label)s_%(class)s_service_metadata', through='registry.MetadataRelation', to='registry.webfeatureservice', verbose_name='web feature services'),
        ),
        migrations.AddField(
            model_name='metadatarelation',
            name='wfs',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.webfeatureservice'),
        ),
        migrations.CreateModel(
            name='HistoricalWebFeatureService',
            fields=[
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('version', models.PositiveSmallIntegerField(choices=[(1, '1.0.0'), (11, '1.1.0'), (111, '1.1.1'), (130, '1.3.0'), (200, '2.0.0'), (202, '2.0.2')], editable=False, help_text='the version of the service type as sem version', verbose_name='version')),
                ('service_url', models.URLField(editable=False, help_text='the base url of the service', max_length=4096, verbose_name='url')),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('licence', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.licence')),
                ('metadata_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='This is the contact for the metadata information.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.metadatacontact', verbose_name='metadata contact')),
                ('service_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='This is the contact for the service provider.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.metadatacontact', verbose_name='service contact')),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.webfeatureservice')),
            ],
            options={
                'verbose_name': 'historical web feature service',
                'verbose_name_plural': 'historical web feature services',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalFeatureType',
            fields=[
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('identifier', models.CharField(editable=False, help_text='this is a string which identifies the element on the remote service.', max_length=500, null=True, verbose_name='identifier')),
                ('bbox_lat_lon', django.contrib.gis.db.models.fields.PolygonField(blank=True, editable=False, help_text='bounding box shall be supplied regardless of what CRS the map server may support, but it may be approximate if the data are not natively in geographic coordinates. The purpose of bounding box is to facilitate geographic searches without requiring coordinate transformations by the search engine.', null=True, srid=4326, verbose_name='bounding box')),
                ('describe_feature_type_document', models.TextField(help_text='the fetched content of the download describe feature type document.', null=True, verbose_name='describe feature type')),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.featuretype')),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('service', models.ForeignKey(blank=True, db_constraint=False, editable=False, help_text='the extras service where this element is part of', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='featuretype', to='registry.webfeatureservice', verbose_name='service')),
            ],
            options={
                'verbose_name': 'historical feature type',
                'verbose_name_plural': 'historical feature types',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.AddField(
            model_name='featuretype',
            name='service',
            field=models.ForeignKey(editable=False, help_text='the extras service where this element is part of', on_delete=django.db.models.deletion.CASCADE, related_name='featuretypes', related_query_name='featuretype', to='registry.webfeatureservice', verbose_name='service'),
        ),
        migrations.CreateModel(
            name='WebFeatureServiceAuthentication',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('username', models.CharField(help_text='the username used for the authentication.', max_length=255, verbose_name='username')),
                ('password', models.CharField(help_text='the password used for the authentication.', max_length=500, verbose_name='password')),
                ('auth_type', models.CharField(choices=[('http_basic', 'Basic'), ('http_digest', 'Digest')], help_text='kind of authentication mechanism shall used.', max_length=100, verbose_name='authentication type')),
                ('key_file', models.FileField(editable=False, max_length=1024, upload_to=registry.models.security.key_file_path)),
                ('service', models.OneToOneField(blank=True, help_text='the optional authentication type and credentials to request the service.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='auth', related_query_name='auth', to='registry.webfeatureservice', verbose_name='web feature service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebFeatureServiceHttpRequestLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timestamp', models.DateTimeField()),
                ('elapsed', models.DurationField()),
                ('method', models.CharField(max_length=20)),
                ('url', models.URLField(max_length=4096)),
                ('body', models.FileField(max_length=1024, upload_to=registry.models.security.request_body_path)),
                ('headers', models.JSONField(default=dict)),
                ('service', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='http_request_logs', related_query_name='http_request_log', to='registry.webfeatureservice')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='%(class)s_http_request_logs', related_query_name='%(class)shttp_request_log', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebFeatureServiceHttpResponseLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status_code', models.IntegerField(default=0)),
                ('reason', models.CharField(max_length=50)),
                ('elapsed', models.DurationField()),
                ('headers', models.JSONField(default=dict)),
                ('url', models.URLField(max_length=4096)),
                ('content', models.FileField(max_length=1024, upload_to=registry.models.security.response_content_path)),
                ('request', models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='response', related_query_name='response', to='registry.webfeatureservicehttprequestlog')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='AllowedWebFeatureServiceOperation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('allowed_area', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326, validators=[extras.validators.geometry_is_empty])),
                ('description', models.CharField(default='', help_text='a short description what this allowed operation controls.', max_length=512, verbose_name='description')),
                ('allowed_groups', models.ManyToManyField(blank=True, related_name='%(class)s_allowed_operations', related_query_name='%(class)s_allowed_operation', to='auth.group')),
                ('secured_feature_types', models.ManyToManyField(help_text='Select one or more feature types.', related_name='allowed_operations', related_query_name='allowed_operation', to='registry.featuretype', verbose_name='secured feature types')),
                ('secured_service', models.ForeignKey(help_text='the service where some layers or feature types are secured of.', on_delete=django.db.models.deletion.CASCADE, related_name='allowed_operations', related_query_name='allowed_operation', to='registry.webfeatureservice', verbose_name='secured service')),
                ('operations', models.ManyToManyField(related_name='allowed_operations', related_query_name='allowed_operation', to='registry.webfeatureserviceoperation')),
            ],
            options={
                'ordering': ['-secured_service'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebFeatureServiceOperationUrl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method', models.PositiveSmallIntegerField(choices=[(1, 'Get'), (2, 'Post')], help_text='the http method you can perform for this url', verbose_name='http method')),
                ('operation', models.PositiveSmallIntegerField(choices=[(1, 'GetCapabilities'), (20, 'GetMap'), (21, 'GetFeatureInfo'), (22, 'DescribeLayer'), (23, 'GetLegendGraphic'), (24, 'GetStyles'), (25, 'PutStyles'), (30, 'GetFeature'), (31, 'Transaction'), (32, 'LockFeature'), (33, 'DescribeFeatureType'), (34, 'GetFeatureWithLock'), (35, 'GetGmlObject'), (36, 'ListStoredQueries'), (37, 'GetPropertyValue'), (38, 'DescribeStoredQueries'), (39, 'CreateStoredQuery'), (40, 'DropStoredQuery'), (50, 'GetRecords'), (51, 'DescribeRecord'), (52, 'GetRecordById'), (53, 'GetDomain'), (54, 'GetRepositoryItem')], help_text='the operation you can perform with this url.', verbose_name='operation')),
                ('url', models.URLField(help_text='the url for this operation', max_length=4096, verbose_name='url')),
                ('mime_types', models.ManyToManyField(blank=True, help_text='all available mime types of the remote url', related_name='%(class)s_operation_urls', related_query_name='%(class)s_operation_url', to='registry.mimetype', verbose_name='internet mime type')),
                ('service', models.ForeignKey(editable=False, help_text='the web feature service for that this url can be used for.', on_delete=django.db.models.deletion.CASCADE, related_name='operation_urls', related_query_name='operation_url', to='registry.webfeatureservice', verbose_name='related web feature service')),
            ],
        ),
        migrations.CreateModel(
            name='WebFeatureServiceProxySetting',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('camouflage', models.BooleanField(default=False, help_text='if true, all related xml documents are secured, by replace all hostname/internet addresses of the related service by the hostname of the current mr. map instance.', verbose_name='camouflage')),
                ('log_response', models.BooleanField(default=False, help_text='if true, all responses of the related service will be logged.', verbose_name='log response')),
                ('secured_service', models.OneToOneField(help_text='the security proxy settings for this service.', on_delete=django.db.models.deletion.CASCADE, related_name='proxy_setting', related_query_name='proxy_setting', to='registry.webfeatureservice', verbose_name='service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebFeatureServiceRemoteMetadata',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('link', models.URLField(help_text='the url where the metadata could be downloaded from.', max_length=4094, verbose_name='download link')),
                ('remote_content', models.TextField(help_text='the fetched content of the download url.', null=True, verbose_name='remote content')),
                ('object_id', models.UUIDField(help_text='the uuid of the described service, layer or feature type', verbose_name='described resource')),
                ('content_type', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='contenttypes.contenttype')),
                ('service', models.ForeignKey(help_text='the service where this remote metadata is related to. This remote metadata was found in the GetCapabilites document of the related service.', on_delete=django.db.models.deletion.CASCADE, related_name='remote_metadata', related_query_name='remote_metadata', to='registry.webfeatureservice', verbose_name='web map service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebMapService',
            fields=[
                ('xml_backup_file', models.FileField(editable=False, help_text='the original xml as backup to restore the xml field.', upload_to=registry.models.document.xml_backup_file_path, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('date_stamp', models.DateTimeField(auto_now_add=True, db_index=True, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('version', models.PositiveSmallIntegerField(choices=[(1, '1.0.0'), (11, '1.1.0'), (111, '1.1.1'), (130, '1.3.0'), (200, '2.0.0'), (202, '2.0.2')], editable=False, help_text='the version of the service type as sem version', verbose_name='version')),
                ('service_url', models.URLField(editable=False, help_text='the base url of the service', max_length=4096, verbose_name='url')),
                ('keywords', models.ManyToManyField(blank=True, help_text='all keywords which are related to the content of this metadata.', related_name='%(class)s_metadata', related_query_name='%(class)s_metadata', to='registry.keyword', verbose_name='keywords')),
                ('licence', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.RESTRICT, to='registry.licence')),
                ('metadata_contact', models.ForeignKey(help_text='This is the contact for the metadata information.', on_delete=django.db.models.deletion.RESTRICT, related_name='metadata_contact_%(class)s_metadata', to='registry.metadatacontact', verbose_name='metadata contact')),
                ('service_contact', models.ForeignKey(help_text='This is the contact for the service provider.', on_delete=django.db.models.deletion.RESTRICT, related_name='service_contact_%(class)s_metadata', to='registry.metadatacontact', verbose_name='service contact')),
            ],
            options={
                'verbose_name': 'web map service',
                'verbose_name_plural': 'web map services',
            },
            bases=(extras.models.HistoricalRecordMixin, models.Model),
        ),
        migrations.AddField(
            model_name='servicemetadatarecord',
            name='self_pointing_wms',
            field=models.ManyToManyField(blank=True, editable=False, help_text='all wms which are linking to this service metadata in there capabilities.', related_name='%(app_label)s_%(class)s_service_metadata', related_query_name='%(app_label)s_%(class)s_service_metadata', through='registry.MetadataRelation', to='registry.webmapservice', verbose_name='web map services'),
        ),
        migrations.AddField(
            model_name='metadatarelation',
            name='wms',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='metadata_relations', related_query_name='metadata_relation', to='registry.webmapservice'),
        ),
        migrations.AddField(
            model_name='layer',
            name='service',
            field=models.ForeignKey(editable=False, help_text='the extras service where this element is part of', on_delete=django.db.models.deletion.CASCADE, related_name='layers', related_query_name='layer', to='registry.webmapservice', verbose_name='service'),
        ),
        migrations.CreateModel(
            name='HistoricalWebMapService',
            fields=[
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('access_constraints', models.TextField(blank=True, help_text='access constraints for the given resource.', null=True, verbose_name='access constraints')),
                ('fees', models.TextField(blank=True, help_text='Costs and of terms of use for the given resource.', null=True, verbose_name='fees')),
                ('use_limitation', models.TextField(blank=True, null=True)),
                ('license_source_note', models.TextField(blank=True, null=True)),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('version', models.PositiveSmallIntegerField(choices=[(1, '1.0.0'), (11, '1.1.0'), (111, '1.1.1'), (130, '1.3.0'), (200, '2.0.0'), (202, '2.0.2')], editable=False, help_text='the version of the service type as sem version', verbose_name='version')),
                ('service_url', models.URLField(editable=False, help_text='the base url of the service', max_length=4096, verbose_name='url')),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('licence', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.licence')),
                ('metadata_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='This is the contact for the metadata information.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.metadatacontact', verbose_name='metadata contact')),
                ('service_contact', models.ForeignKey(blank=True, db_constraint=False, help_text='This is the contact for the service provider.', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='registry.metadatacontact', verbose_name='service contact')),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.webmapservice')),
            ],
            options={
                'verbose_name': 'historical web map service',
                'verbose_name_plural': 'historical web map services',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='HistoricalLayer',
            fields=[
                ('mptt_lft', models.PositiveIntegerField(editable=False, help_text='The left value of the node', verbose_name='left')),
                ('mptt_rgt', models.PositiveIntegerField(editable=False, help_text='The right value of the node', verbose_name='right')),
                ('mptt_depth', models.PositiveIntegerField(editable=False, help_text='The hierarchy level of this node inside the tree', verbose_name='depth')),
                ('history_day', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='TIMEZONE', output_field=models.DateField(), template="(%(function)s('EUROPE/BERLIN', %(expressions)s))::date"), output_field=models.DateField())),
                ('history_week', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(WEEK FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_month', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(MONTH FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('history_year', models.GeneratedField(db_index=True, db_persist=True, expression=models.Func(models.F('history_date'), function='EXTRACT', output_field=models.IntegerField(), template="EXTRACT(YEAR FROM (TIMEZONE('EUROPE/BERLIN', %(expressions)s)))"), output_field=models.IntegerField())),
                ('xml_backup_file', models.TextField(editable=False, help_text='the original xml as backup to restore the xml field.', max_length=100, verbose_name='xml backup')),
                ('id', models.UUIDField(db_index=True, default=uuid.uuid4, editable=False)),
                ('date_stamp', models.DateTimeField(blank=True, db_index=True, editable=False, help_text='date that the metadata was created. If this is a metadata record which is parsed from remote iso metadata, the date stamp of the remote iso metadata will be used.', verbose_name='date stamp')),
                ('file_identifier', models.CharField(db_index=True, default=uuid.uuid4, editable=False, help_text='the parsed file identifier from the iso metadata xml (gmd:fileIdentifier) OR for example if it is a layer/featuretypethe uuid of the described layer/featuretype shall be used to identify the generated iso metadata xml.', max_length=1000, verbose_name='file identifier')),
                ('origin', models.CharField(choices=[('Capabilities', 'Capabilities'), ('Upload', 'Upload'), ('File System Import', 'File System Import'), ('Editor', 'Editor'), ('Catalogue', 'Catalogue')], editable=False, help_text='Where the metadata record comes from.', max_length=20, verbose_name='origin')),
                ('origin_url', models.URLField(blank=True, editable=False, help_text='the url of the document where the information of this metadata record comes from', max_length=4096, null=True, verbose_name='origin url')),
                ('title', models.CharField(default='', help_text='a short descriptive title for this metadata', max_length=1000, verbose_name='title')),
                ('abstract', models.TextField(blank=True, default='', help_text='brief summary of the content of this metadata.', verbose_name='abstract')),
                ('is_broken', models.BooleanField(default=False, editable=False, help_text='TODO', verbose_name='is broken')),
                ('is_customized', models.BooleanField(default=False, editable=False, help_text='If the metadata record is customized, this flag is True', verbose_name='is customized')),
                ('insufficient_quality', models.TextField(blank=True, default='', editable=False, help_text='TODO')),
                ('is_searchable', models.BooleanField(default=False, help_text='only searchable metadata will be returned from the search api', verbose_name='is searchable')),
                ('hits', models.IntegerField(default=0, editable=False, help_text='how many times this metadata was requested by a client', verbose_name='hits')),
                ('preview_image', models.TextField(blank=True, max_length=100, null=True)),
                ('is_active', models.BooleanField(default=False, help_text='Used to activate/deactivate the service. If it is deactivated, you cant request the service through the Mr. Map proxy.', verbose_name='is active?')),
                ('identifier', models.CharField(editable=False, help_text='this is a string which identifies the element on the remote service.', max_length=500, null=True, verbose_name='identifier')),
                ('bbox_lat_lon', django.contrib.gis.db.models.fields.PolygonField(blank=True, editable=False, help_text='bounding box shall be supplied regardless of what CRS the map server may support, but it may be approximate if the data are not natively in geographic coordinates. The purpose of bounding box is to facilitate geographic searches without requiring coordinate transformations by the search engine.', null=True, srid=4326, verbose_name='bounding box')),
                ('is_queryable', models.BooleanField(default=False, editable=False, help_text='flag to signal if this layer provides factual information or not. Parsed from capabilities.', verbose_name='is queryable')),
                ('is_opaque', models.BooleanField(default=False, editable=False, help_text='flag to signal if this layer support transparency content or not. Parsed from capabilities.', verbose_name='is opaque')),
                ('is_cascaded', models.BooleanField(default=False, editable=False, help_text='WMS cascading allows to expose layers coming from other WMS servers as if they were local layers', verbose_name='is cascaded')),
                ('scale_min', models.FloatField(blank=True, editable=False, help_text='minimum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale minimum value')),
                ('scale_max', models.FloatField(blank=True, editable=False, help_text='maximum scale for a possible request to this layer. If the request is out of the given scope, the service will response with empty transparentimages. None value means no restriction.', null=True, verbose_name='scale maximum value')),
                ('history_id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('mptt_tree', models.ForeignKey(blank=True, db_constraint=False, editable=False, help_text='The unique tree, where this node is part of', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='%(app_label)s_%(class)s_node', to='mptt2.tree', verbose_name='tree')),
                ('history_relation', models.ForeignKey(db_constraint=False, on_delete=django.db.models.deletion.DO_NOTHING, related_name='change_logs', to='registry.layer')),
                ('mptt_parent', models.ForeignKey(blank=True, db_constraint=False, editable=False, help_text='The parent of this node', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='child', to='registry.layer', verbose_name='parent')),
                ('service', models.ForeignKey(blank=True, db_constraint=False, editable=False, help_text='the extras service where this element is part of', null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', related_query_name='layer', to='registry.webmapservice', verbose_name='service')),
            ],
            options={
                'verbose_name': 'historical layer',
                'verbose_name_plural': 'historical layers',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        migrations.CreateModel(
            name='WebMapServiceAuthentication',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('username', models.CharField(help_text='the username used for the authentication.', max_length=255, verbose_name='username')),
                ('password', models.CharField(help_text='the password used for the authentication.', max_length=500, verbose_name='password')),
                ('auth_type', models.CharField(choices=[('http_basic', 'Basic'), ('http_digest', 'Digest')], help_text='kind of authentication mechanism shall used.', max_length=100, verbose_name='authentication type')),
                ('key_file', models.FileField(editable=False, max_length=1024, upload_to=registry.models.security.key_file_path)),
                ('service', models.OneToOneField(blank=True, help_text='the optional authentication type and credentials to request the service.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='auth', related_query_name='auth', to='registry.webmapservice', verbose_name='web map service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebMapServiceHttpRequestLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timestamp', models.DateTimeField()),
                ('elapsed', models.DurationField()),
                ('method', models.CharField(max_length=20)),
                ('url', models.URLField(max_length=4096)),
                ('body', models.FileField(max_length=1024, upload_to=registry.models.security.request_body_path)),
                ('headers', models.JSONField(default=dict)),
                ('service', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='http_request_logs', related_query_name='http_request_log', to='registry.webmapservice')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='%(class)s_http_request_logs', related_query_name='%(class)shttp_request_log', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebMapServiceHttpResponseLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status_code', models.IntegerField(default=0)),
                ('reason', models.CharField(max_length=50)),
                ('elapsed', models.DurationField()),
                ('headers', models.JSONField(default=dict)),
                ('url', models.URLField(max_length=4096)),
                ('content', models.FileField(max_length=1024, upload_to=registry.models.security.response_content_path)),
                ('request', models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='response', related_query_name='response', to='registry.webmapservicehttprequestlog')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='GetMapProbeResult',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status_code', models.SmallIntegerField(blank=True, default=None, editable=False, help_text='The http status code of the response', null=True, verbose_name='HTTP status code')),
                ('monitored_uri', models.URLField(editable=False, help_text='This is the url which was monitored', max_length=4096, verbose_name='monitored uri')),
                ('request_duration', models.DurationField(blank=True, editable=False, help_text='elapsed time of the request', null=True, verbose_name='request duration')),
                ('date_created', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the task result was created in UTC', verbose_name='Created DateTime')),
                ('date_done', models.DateTimeField(blank=True, help_text='Datetime field when the task was completed in UTC', null=True, verbose_name='Completed DateTime')),
                ('check_response_image_success', models.BooleanField(blank=True, default=None, null=True)),
                ('check_response_image_message', models.TextField(blank=True, default=None, null=True)),
                ('check_response_does_not_contain_success', models.BooleanField(blank=True, default=None, null=True)),
                ('check_response_does_not_contain_message', models.TextField(blank=True, default=None, null=True)),
                ('run', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='%(app_label)s_%(class)ss', related_query_name='%(app_label)s_%(class)s', to='registry.webmapservicemonitoringrun', verbose_name='Run')),
            ],
            options={
                'ordering': ['-date_done'],
                'get_latest_by': 'date_done',
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='GetCapabilitiesProbeResult',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status_code', models.SmallIntegerField(blank=True, default=None, editable=False, help_text='The http status code of the response', null=True, verbose_name='HTTP status code')),
                ('monitored_uri', models.URLField(editable=False, help_text='This is the url which was monitored', max_length=4096, verbose_name='monitored uri')),
                ('request_duration', models.DurationField(blank=True, editable=False, help_text='elapsed time of the request', null=True, verbose_name='request duration')),
                ('date_created', models.DateTimeField(auto_now_add=True, help_text='Datetime field when the task result was created in UTC', verbose_name='Created DateTime')),
                ('date_done', models.DateTimeField(blank=True, help_text='Datetime field when the task was completed in UTC', null=True, verbose_name='Completed DateTime')),
                ('check_response_is_valid_xml_success', models.BooleanField(blank=True, default=None, null=True)),
                ('check_response_is_valid_xml_message', models.TextField(blank=True, default=None, null=True)),
                ('check_response_does_not_contain_success', models.BooleanField(blank=True, default=None, null=True)),
                ('check_response_does_not_contain_message', models.TextField(blank=True, default=None, null=True)),
                ('check_response_does_contain_success', models.BooleanField(blank=True, default=None, null=True)),
                ('check_response_does_contain_message', models.TextField(blank=True, default=None, null=True)),
                ('run', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='%(app_label)s_%(class)ss', related_query_name='%(app_label)s_%(class)s', to='registry.webmapservicemonitoringrun', verbose_name='Run')),
            ],
            options={
                'ordering': ['-date_done'],
                'get_latest_by': 'date_done',
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebMapServiceMonitoringSetting',
            fields=[
                ('periodictask_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='django_celery_beat.periodictask')),
                ('service', models.ForeignKey(help_text='this is the service which shall be monitored', on_delete=django.db.models.deletion.CASCADE, related_name='web_map_service_monitorings', related_query_name='web_map_service_monitoring', to='registry.webmapservice', verbose_name='web map service')),
            ],
            bases=('django_celery_beat.periodictask',),
        ),
        migrations.AddField(
            model_name='webmapservicemonitoringrun',
            name='setting',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to='registry.webmapservicemonitoringsetting'),
        ),
        migrations.CreateModel(
            name='GetMapProbe',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timeout', models.IntegerField(blank=True, default=30)),
                ('check_response_does_not_contain', models.CharField(blank=True, default='ExceptionReport>,ServiceException>', help_text='comma seperated search strings like: ExceptionReport>,ServiceException>', max_length=256, verbose_name='Check response does not contain')),
                ('height', models.IntegerField(default=256)),
                ('width', models.IntegerField(default=256)),
                ('bbox_lat_lon', django.contrib.gis.db.models.fields.PolygonField(blank=True, null=True, srid=4326, verbose_name='bounding box')),
                ('check_response_is_image', models.BooleanField(default=True)),
                ('layers', models.ManyToManyField(to='registry.layer')),
                ('format', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='registry.mimetype')),
                ('reference_system', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='registry.referencesystem')),
                ('setting', models.ForeignKey(help_text='The related setting object', on_delete=django.db.models.deletion.CASCADE, related_name='%(app_label)s_%(class)ss', related_query_name='%(app_label)s_%(class)s', to='registry.webmapservicemonitoringsetting', verbose_name='Setting')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='GetCapabilitiesProbe',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timeout', models.IntegerField(blank=True, default=30)),
                ('check_response_does_not_contain', models.CharField(blank=True, default='ExceptionReport>,ServiceException>', help_text='comma seperated search strings like: ExceptionReport>,ServiceException>', max_length=256, verbose_name='Check response does not contain')),
                ('check_response_is_valid_xml', models.BooleanField(default=True)),
                ('check_response_does_contain', models.CharField(blank=True, default='Title>,Abstract>', help_text='comma seperated search strings like: Title>,Abstract>', max_length=256, verbose_name='Check response does contain')),
                ('setting', models.ForeignKey(help_text='The related setting object', on_delete=django.db.models.deletion.CASCADE, related_name='%(app_label)s_%(class)ss', related_query_name='%(app_label)s_%(class)s', to='registry.webmapservicemonitoringsetting', verbose_name='Setting')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='AllowedWebMapServiceOperation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('allowed_area', django.contrib.gis.db.models.fields.MultiPolygonField(blank=True, null=True, srid=4326, validators=[extras.validators.geometry_is_empty])),
                ('description', models.CharField(default='', help_text='a short description what this allowed operation controls.', max_length=512, verbose_name='description')),
                ('allowed_groups', models.ManyToManyField(blank=True, related_name='%(class)s_allowed_operations', related_query_name='%(class)s_allowed_operation', to='auth.group')),
                ('secured_layers', models.ManyToManyField(help_text='Select one or more layers. Note that all sub layers of a selected layer will also be secured.', related_name='allowed_operations', related_query_name='allowed_operation', to='registry.layer', verbose_name='secured layers')),
                ('secured_service', models.ForeignKey(help_text='the service where some layers or feature types are secured of.', on_delete=django.db.models.deletion.CASCADE, related_name='allowed_operations', related_query_name='allowed_operation', to='registry.webmapservice', verbose_name='secured service')),
                ('operations', models.ManyToManyField(related_name='allowed_operations', related_query_name='allowed_operation', to='registry.webmapserviceoperation')),
            ],
            options={
                'ordering': ['-secured_service'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebMapServiceOperationUrl',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method', models.PositiveSmallIntegerField(choices=[(1, 'Get'), (2, 'Post')], help_text='the http method you can perform for this url', verbose_name='http method')),
                ('operation', models.PositiveSmallIntegerField(choices=[(1, 'GetCapabilities'), (20, 'GetMap'), (21, 'GetFeatureInfo'), (22, 'DescribeLayer'), (23, 'GetLegendGraphic'), (24, 'GetStyles'), (25, 'PutStyles'), (30, 'GetFeature'), (31, 'Transaction'), (32, 'LockFeature'), (33, 'DescribeFeatureType'), (34, 'GetFeatureWithLock'), (35, 'GetGmlObject'), (36, 'ListStoredQueries'), (37, 'GetPropertyValue'), (38, 'DescribeStoredQueries'), (39, 'CreateStoredQuery'), (40, 'DropStoredQuery'), (50, 'GetRecords'), (51, 'DescribeRecord'), (52, 'GetRecordById'), (53, 'GetDomain'), (54, 'GetRepositoryItem')], help_text='the operation you can perform with this url.', verbose_name='operation')),
                ('url', models.URLField(help_text='the url for this operation', max_length=4096, verbose_name='url')),
                ('mime_types', models.ManyToManyField(blank=True, help_text='all available mime types of the remote url', related_name='%(class)s_operation_urls', related_query_name='%(class)s_operation_url', to='registry.mimetype', verbose_name='internet mime type')),
                ('service', models.ForeignKey(help_text='the web map service for that this url can be used for.', on_delete=django.db.models.deletion.CASCADE, related_name='operation_urls', related_query_name='operation_url', to='registry.webmapservice', verbose_name='related web map service')),
            ],
        ),
        migrations.CreateModel(
            name='WebMapServiceProxySetting',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('camouflage', models.BooleanField(default=False, help_text='if true, all related xml documents are secured, by replace all hostname/internet addresses of the related service by the hostname of the current mr. map instance.', verbose_name='camouflage')),
                ('log_response', models.BooleanField(default=False, help_text='if true, all responses of the related service will be logged.', verbose_name='log response')),
                ('secured_service', models.OneToOneField(help_text='the security proxy settings for this service.', on_delete=django.db.models.deletion.CASCADE, related_name='proxy_setting', related_query_name='proxy_setting', to='registry.webmapservice', verbose_name='service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebMapServiceRemoteMetadata',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('link', models.URLField(help_text='the url where the metadata could be downloaded from.', max_length=4094, verbose_name='download link')),
                ('remote_content', models.TextField(help_text='the fetched content of the download url.', null=True, verbose_name='remote content')),
                ('object_id', models.UUIDField(help_text='the uuid of the described service, layer or feature type', verbose_name='described resource')),
                ('content_type', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='contenttypes.contenttype')),
                ('service', models.ForeignKey(help_text='the service where this remote metadata is related to. This remote metadata was found in the GetCapabilites document of the related service.', on_delete=django.db.models.deletion.CASCADE, related_name='remote_metadata', related_query_name='remote_metadata', to='registry.webmapservice', verbose_name='web map service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WmsConformityCheckRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('passed', models.BooleanField(blank=True, null=True)),
                ('report', models.TextField(blank=True, null=True)),
                ('report_type', models.TextField(choices=[('text/html', 'Html'), ('application/json', 'Json')])),
                ('config', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='registry.conformitycheckconfiguration')),
                ('service', models.ForeignKey(help_text='the service targeted by this check', on_delete=django.db.models.deletion.CASCADE, to='registry.webmapservice', verbose_name='service')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='WebFeatureServiceAnalyzedResponseLog',
            fields=[
                ('analyzedresponselog_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='registry.analyzedresponselog')),
                ('response', models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='analyzed_response', related_query_name='analyzed_response', to='registry.webfeatureservicehttpresponselog')),
            ],
            bases=('registry.analyzedresponselog',),
        ),
        migrations.CreateModel(
            name='WebMapServiceAnalyzedResponseLog',
            fields=[
                ('analyzedresponselog_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='registry.analyzedresponselog')),
                ('response', models.OneToOneField(on_delete=django.db.models.deletion.PROTECT, related_name='analyzed_response', related_query_name='analyzed_response', to='registry.webmapservicehttpresponselog')),
            ],
            bases=('registry.analyzedresponselog',),
        ),
        migrations.CreateModel(
            name='ConformityCheckConfigurationInternal',
            fields=[
                ('conformitycheckconfiguration_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='registry.conformitycheckconfiguration')),
                ('mandatory_rule_sets', models.ManyToManyField(related_name='mandatory_rule_sets', to='registry.ruleset')),
                ('optional_rule_sets', models.ManyToManyField(blank=True, related_name='optional_rule_sets', to='registry.ruleset')),
            ],
            bases=('registry.conformitycheckconfiguration',),
        ),
        migrations.CreateModel(
            name='LayerTimeExtent',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timerange', django.contrib.postgres.fields.ranges.DateTimeRangeField()),
                ('resolution', models.DurationField(blank=True, null=True)),
                ('layer', models.ForeignKey(help_text='the related layer of this time dimension entity', on_delete=django.db.models.deletion.CASCADE, related_name='time_extents', related_query_name='time_extent', to='registry.layer', verbose_name='layer')),
            ],
            options={
                'indexes': [django.contrib.postgres.indexes.GistIndex(fields=['timerange'], name='registry_la_timeran_38cdf2_gist'), models.Index(fields=['layer', 'timerange'], name='registry_la_layer_i_2250f7_idx')],
            },
        ),
        migrations.AddIndex(
            model_name='catalogueservice',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_ca_title_a7106d_idx'),
        ),
        migrations.AddConstraint(
            model_name='catalogueserviceoperationurl',
            constraint=models.UniqueConstraint(fields=('method', 'operation', 'service'), name='registry_catalogueserviceoperationurl_unique_together_method_id_operation_service'),
        ),
        migrations.AddIndex(
            model_name='datasetmetadatarecord',
            index=models.Index(fields=['code', 'code_space'], name='registry_da_code_44ac51_idx'),
        ),
        migrations.AddIndex(
            model_name='datasetmetadatarecord',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_da_title_08cf6a_idx'),
        ),
        migrations.AddConstraint(
            model_name='datasetmetadatarecord',
            constraint=models.UniqueConstraint(condition=models.Q(('code', ''), ('code_space', ''), _negated=True), fields=('file_identifier', 'code', 'code_space'), name='registry_datasetmetadatarecord_unique_together_code__and_code_space'),
        ),
        migrations.AddConstraint(
            model_name='datasetmetadatarecord',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('spatial_res_type', ''), ('spatial_res_value', None)), models.Q(('spatial_res_type', 'groundDistance'), ('spatial_res_value__gte', 0)), models.Q(('spatial_res_type', 'scaleDenominator'), ('spatial_res_value__gte', 0)), _connector='OR'), name='registry_datasetmetadatarecord_check_spatial_res'),
        ),
        migrations.AddConstraint(
            model_name='datasetmetadatarecord',
            constraint=models.UniqueConstraint(fields=('file_identifier',), name='registry_datasetmetadatarecord_unique_file_identifier'),
        ),
        migrations.AddIndex(
            model_name='harvestingjob',
            index=models.Index(fields=['date_created'], name='registry_ha_date_cr_7fa6db_idx'),
        ),
        migrations.AddIndex(
            model_name='harvestingjob',
            index=models.Index(fields=['done_at'], name='registry_ha_done_at_0a96d0_idx'),
        ),
        migrations.AddConstraint(
            model_name='harvestingjob',
            constraint=models.UniqueConstraint(condition=models.Q(('done_at__isnull', True)), fields=('service',), name='only_one_unfinished_job_per_service', violation_error_message='There is an existing noncompleted job for this service.'),
        ),
        migrations.AddIndex(
            model_name='harvestedmetadatarelation',
            index=models.Index(fields=['harvesting_job', 'dataset_metadata_record'], name='registry_ha_harvest_c0a9b2_idx'),
        ),
        migrations.AddIndex(
            model_name='harvestedmetadatarelation',
            index=models.Index(fields=['harvesting_job', 'dataset_metadata_record', 'collecting_state'], name='registry_ha_harvest_0b930b_idx'),
        ),
        migrations.AddIndex(
            model_name='harvestedmetadatarelation',
            index=models.Index(fields=['harvesting_job', 'service_metadata_record'], name='registry_ha_harvest_c0dbc4_idx'),
        ),
        migrations.AddIndex(
            model_name='harvestedmetadatarelation',
            index=models.Index(fields=['harvesting_job', 'service_metadata_record', 'collecting_state'], name='registry_ha_harvest_ec0096_idx'),
        ),
        migrations.AddIndex(
            model_name='harvestedmetadatarelation',
            index=models.Index(fields=['harvesting_job', 'id'], name='registry_ha_harvest_d15840_idx'),
        ),
        migrations.AddConstraint(
            model_name='harvestedmetadatarelation',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('dataset_metadata_record__isnull', True), ('service_metadata_record__isnull', False)), models.Q(('dataset_metadata_record__isnull', False), ('service_metadata_record__isnull', True)), _connector='OR'), name='dm_record_or_sm_record', violation_error_message='wrong relation type. dataset_metadata_record or service_metadata_record, not both is required.'),
        ),
        migrations.AddConstraint(
            model_name='harvestedmetadatarelation',
            constraint=models.UniqueConstraint(condition=models.Q(('collecting_state', 0), _negated=True), fields=('harvesting_job', 'dataset_metadata_record', 'collecting_state'), name='atomic_new_updated_or_exsisting_collecting_state_for_dm_record'),
        ),
        migrations.AddConstraint(
            model_name='harvestedmetadatarelation',
            constraint=models.UniqueConstraint(condition=models.Q(('collecting_state', 0), _negated=True), fields=('harvesting_job', 'service_metadata_record', 'collecting_state'), name='atomic_new_updated_or_exsisting_collecting_state_for_sm_record'),
        ),
        migrations.AddIndex(
            model_name='temporarymdmetadatafile',
            index=models.Index(fields=['job_id', '-id'], name='registry_te_job_id_5e81a1_idx'),
        ),
        migrations.AddIndex(
            model_name='webfeatureservice',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_we_title_f5ff5b_idx'),
        ),
        migrations.AddIndex(
            model_name='featuretype',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_fe_title_ae782a_idx'),
        ),
        migrations.AddIndex(
            model_name='featuretype',
            index=django.contrib.postgres.indexes.GistIndex(condition=models.Q(('bbox_lat_lon__isnull', False)), fields=['bbox_lat_lon'], name='featuretype_bbox_not_null'),
        ),
        migrations.AddConstraint(
            model_name='featuretype',
            constraint=models.UniqueConstraint(fields=('service', 'identifier'), name='unique_identifer_per_wfs'),
        ),
        migrations.AddConstraint(
            model_name='featuretype',
            constraint=models.UniqueConstraint(fields=('file_identifier',), name='registry_featuretype_unique_file_identifier'),
        ),
        migrations.AddConstraint(
            model_name='allowedwebfeatureserviceoperation',
            constraint=models.CheckConstraint(condition=models.Func(models.F('allowed_area'), function='NOT st_isempty', output_field=models.BooleanField()), name='registry_allowedwebfeatureserviceoperation_allowed_area_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='webfeatureserviceoperationurl',
            constraint=models.UniqueConstraint(fields=('method', 'operation', 'service'), name='registry_webfeatureserviceoperationurl_unique_together_method_id_operation_service'),
        ),
        migrations.AddConstraint(
            model_name='webfeatureserviceproxysetting',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('camouflage', True), ('log_response', True)), models.Q(('camouflage', True), ('log_response', False)), models.Q(('camouflage', False), ('log_response', False)), _connector='OR'), name='registry_webfeatureserviceproxysetting_log_response_without_camouflage'),
        ),
        migrations.AddIndex(
            model_name='webmapservice',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_we_title_42e946_idx'),
        ),
        migrations.AddIndex(
            model_name='servicemetadatarecord',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_se_title_3f5259_idx'),
        ),
        migrations.AddConstraint(
            model_name='servicemetadatarecord',
            constraint=models.UniqueConstraint(condition=models.Q(('code', ''), ('code_space', ''), _negated=True), fields=('file_identifier', 'code', 'code_space'), name='registry_servicemetadatarecord_unique_together_code__and_code_space'),
        ),
        migrations.AddConstraint(
            model_name='servicemetadatarecord',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('spatial_res_type', ''), ('spatial_res_value', None)), models.Q(('spatial_res_type', 'groundDistance'), ('spatial_res_value__gte', 0)), models.Q(('spatial_res_type', 'scaleDenominator'), ('spatial_res_value__gte', 0)), _connector='OR'), name='registry_servicemetadatarecord_check_spatial_res'),
        ),
        migrations.AddConstraint(
            model_name='servicemetadatarecord',
            constraint=models.UniqueConstraint(fields=('file_identifier',), name='registry_servicemetadatarecord_unique_file_identifier'),
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', False), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', False), ('feature_type__isnull', True), ('layer__isnull', False), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', False), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', False), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', False), ('feature_type__isnull', False), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', False), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', False), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', False), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', False)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', False)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', False), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', False), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', False), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', True), ('wfs__isnull', True), ('wms__isnull', True)), models.Q(('csw__isnull', True), ('dataset_metadata__isnull', True), ('feature_type__isnull', True), ('layer__isnull', True), ('service_metadata__isnull', False), ('wfs__isnull', True), ('wms__isnull', True)), _connector='OR'), name='one_related_object_selected'),
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.UniqueConstraint(fields=('service_metadata', 'layer'), name='unique_service_metadata_representation_for_layer'),
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.UniqueConstraint(fields=('service_metadata', 'feature_type'), name='unique_service_metadata_representation_for_feature_type'),
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.UniqueConstraint(fields=('service_metadata', 'csw'), name='unique_service_metadata_representation_for_csw'),
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.UniqueConstraint(fields=('service_metadata', 'wms'), name='unique_service_metadata_representation_for_wms'),
        ),
        migrations.AddConstraint(
            model_name='metadatarelation',
            constraint=models.UniqueConstraint(fields=('service_metadata', 'wfs'), name='unique_service_metadata_representation_for_wfs'),
        ),
        migrations.AddIndex(
            model_name='layer',
            index=models.Index(fields=['mptt_tree_id', 'mptt_lft', 'mptt_rgt'], name='registry_la_mptt_tr_1a07c6_idx'),
        ),
        migrations.AddIndex(
            model_name='layer',
            index=models.Index(fields=['title', 'file_identifier'], name='registry_la_title_cf89f2_idx'),
        ),
        migrations.AddIndex(
            model_name='layer',
            index=django.contrib.postgres.indexes.GistIndex(condition=models.Q(('bbox_lat_lon__isnull', False)), fields=['bbox_lat_lon'], name='layer_bbox_not_null'),
        ),
        migrations.AddConstraint(
            model_name='layer',
            constraint=models.UniqueConstraint(fields=('service', 'identifier'), name='unique_identifer_per_wms'),
        ),
        migrations.AddConstraint(
            model_name='layer',
            constraint=models.CheckConstraint(condition=models.Q(('mptt_rgt__gt', models.F('mptt_lft'))), name='registry_layer_rgt_gt_lft'),
        ),
        migrations.AddConstraint(
            model_name='layer',
            constraint=models.UniqueConstraint(fields=('file_identifier',), name='registry_layer_unique_file_identifier'),
        ),
        migrations.AddConstraint(
            model_name='allowedwebmapserviceoperation',
            constraint=models.CheckConstraint(condition=models.Func(models.F('allowed_area'), function='NOT st_isempty', output_field=models.BooleanField()), name='registry_allowedwebmapserviceoperation_allowed_area_not_empty'),
        ),
        migrations.AddConstraint(
            model_name='webmapserviceoperationurl',
            constraint=models.UniqueConstraint(fields=('method', 'operation', 'service'), name='registry_webmapserviceoperationurl_unique_together_method_id_operation_service'),
        ),
        migrations.AddConstraint(
            model_name='webmapserviceproxysetting',
            constraint=models.CheckConstraint(condition=models.Q(models.Q(('camouflage', True), ('log_response', True)), models.Q(('camouflage', True), ('log_response', False)), models.Q(('camouflage', False), ('log_response', False)), _connector='OR'), name='registry_webmapserviceproxysetting_log_response_without_camouflage'),
        ),
    ]
